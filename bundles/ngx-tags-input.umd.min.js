!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("@angular/core"),require("ngx-bootstrap/typeahead"),require("@angular/common"),require("@angular/forms")):"function"==typeof define&&define.amd?define("ngx-tags-input",["exports","@angular/core","ngx-bootstrap/typeahead","@angular/common","@angular/forms"],t):t(e["ngx-tags-input"]={},e.ng.core,e.typeahead,e.ng.common,e.ng.forms)}(this,function(e,t,n,a,s){"use strict";function i(){}var o={provide:s.NG_VALUE_ACCESSOR,useExisting:t.forwardRef(function(){return p}),multi:!0},p=(l.prototype.getPlaceholder=function(){return this.tags&&0<this.tags.length?"":this.placeholder},l.prototype.tagsChanged=function(e,t){this.onChangeCallback(this.tags),this.onTagsChanged.emit({change:e,tag:t}),this.maximumOfTagsReached()&&this.onMaxTagsReached.emit()},l.prototype.removeLastTag=function(e){this.removeLastOnBackspace&&this.tags.length&&""===e.value&&this.removeTag(this.tags[this.tags.length-1])},l.prototype.addTag=function(e){var t;if(""!==e.value.trim()){var n=((t={})[this.displayField]=e.value,t);this.addPredefinedTag(n)}e.value=""},l.prototype.keyDownEvent=function(e,t){188===e.which&&(t.value=t.value.slice(0,-1),this.addTag(t))},l.prototype.addPredefinedTag=function(e){this.maximumOfTagsReached()||(this.tags.push(e),this.tagsChanged("add",e))},l.prototype.removeTag=function(t){this.isDeleteable(t)&&(this.tags=this.tags.filter(function(e){return t!==e}),this.tagsChanged("remove",t))},l.prototype.maximumOfTagsReached=function(){return"undefined"!=typeof this.maxTags&&this.tags&&this.tags.length>=this.maxTags},l.prototype.isDeleteable=function(e){return!("undefined"!=typeof e.deleteable&&!e.deleteable)&&this.canDeleteTags},l.prototype.typeaheadOnSelect=function(e){var t;"string"==typeof e.item?this.addPredefinedTag(((t={})[this.displayField]=e.value,t)):this.addPredefinedTag(e.item),this.selected=""},l.prototype.typeaheadOnNoMatch=function(e){"undefined"!=typeof this.onNoOptionsMatch&&this.onNoOptionsMatch.emit(e)},l.prototype.writeValue=function(e){e!==this.tags&&(this.tags=e)},l.prototype.registerOnChange=function(e){this.onChangeCallback=e},l.prototype.registerOnTouched=function(e){this.onTouchedCallback=e},l.decorators=[{type:t.Component,args:[{selector:"ngx-tags-input",template:'\n    <div class="tags-input">\n        <span class="tags-input__tag label label-primary badge badge-primary" *ngFor="let tag of tags">\n            {{tag[displayField]}}\n            <span *ngIf="isDeleteable(tag)" role="button" class="tags-input__tag-remove-btn" (click)="removeTag(tag)" (touch)="removeTag(tag)">\n                <span aria-hidden="true">&times;</span>\n                <span class="sr-only">Close</span>\n            </span>\n        </span>\n        <input\n            *ngIf="options === null; else withTypeahead" \n            class="tags-input__input-field" \n            type="text" \n            [placeholder]="getPlaceholder()"\n            name="tags"\n            (keyup)="keyDownEvent($event, tagInput)"\n            (keyup.enter)="addTag(tagInput)" (keydown.backspace)="removeLastTag(tagInput)"\n            [disabled]="!canAddTags || maximumOfTagsReached()"\n            [hidden]="!canAddTags || maximumOfTagsReached()"\n            #tagInput />\n        <ng-template #withTypeahead>\n          <input\n            *ngIf="options !== null" \n            class="tags-input__input-field" \n            type="text" \n            [placeholder]="getPlaceholder()"\n            name="tags"\n            (keydown.backspace)="removeLastTag(tagInput)"\n            [(ngModel)]="selected" \n            [typeahead]="options"\n            [typeaheadOptionField]="displayField"\n            (typeaheadOnSelect)="typeaheadOnSelect($event)"\n            (typeaheadNoResults)="typeaheadOnNoMatch($event)"\n            [typeaheadMinLength]="minLengthBeforeOptions"\n            [typeaheadScrollable]="scrollableOptions"\n            [typeaheadLatinize]="true"\n            [typeaheadOptionsInScrollableView]="scrollableOptionsInView"\n            [disabled]="!canAddTags || maximumOfTagsReached()"\n            [hidden]="!canAddTags || maximumOfTagsReached()"\n            #tagInput />\n        </ng-template>\n    </div>\n',providers:[o],styles:["\n    :host {\n        overflow: auto;\n        white-space: nowrap;\n    }\n\n    .tags-input {\n        align-items: center;\n        display: flex;\n        flex-wrap: wrap;\n    }\n\n    .tags-input__tag {\n        display: inline-block;\n        margin-bottom: 2px;\n        margin-right: 5px;\n        padding-right: 0.3em;\n    }\n\n    .tags-input__tag-remove-btn {\n        cursor: pointer;\n        display: inline-block;\n        font-size: 12px;\n        margin: -3px 0 0 3px;\n        padding: 0;\n        vertical-align: top;\n    }\n\n    .tags-input__input-field {\n        border: none;\n        flex-grow: 1;\n        outline: none;\n    }\n"]}]}],l.propDecorators={maxTags:[{type:t.Input}],removeLastOnBackspace:[{type:t.Input}],canDeleteTags:[{type:t.Input}],canAddTags:[{type:t.Input}],placeholder:[{type:t.Input}],options:[{type:t.Input}],displayField:[{type:t.Input}],minLengthBeforeOptions:[{type:t.Input}],scrollableOptions:[{type:t.Input}],scrollableOptionsInView:[{type:t.Input}],onTagsChanged:[{type:t.Output}],onMaxTagsReached:[{type:t.Output}],onNoOptionsMatch:[{type:t.Output}]},l);function l(){this.selected="",this.tags=[],this.onTouchedCallback=i,this.onChangeCallback=i,this.removeLastOnBackspace=!1,this.canDeleteTags=!0,this.canAddTags=!0,this.placeholder="",this.options=null,this.displayField="displayValue",this.minLengthBeforeOptions=1,this.scrollableOptions=!1,this.scrollableOptionsInView=5,this.onTagsChanged=new t.EventEmitter,this.onMaxTagsReached=new t.EventEmitter,this.onNoOptionsMatch=new t.EventEmitter}var d=(g.decorators=[{type:t.NgModule,args:[{declarations:[p],imports:[s.FormsModule,a.CommonModule,n.TypeaheadModule.forRoot()],exports:[p]}]}],g);function g(){}e.NgxTagsInputComponent=p,e.NgxTagsInputModule=d,Object.defineProperty(e,"__esModule",{value:!0})});
//# sourceMappingURL=ngx-tags-input.umd.min.js.map